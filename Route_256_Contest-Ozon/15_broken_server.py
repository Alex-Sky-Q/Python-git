# Задана последовательность запросов к серверу от клиентов. Каждый запрос характеризуется идентификатором клиента
# (целое число от 1 до 109). Т.е. одинаковые идентификаторы для запросов означают, что запросы сделаны одним клиентом.
# Сервер может обработать запросы от не более двух разных клиентов. Вы хотите включить его на некоторое время так,
# чтобы обработать макс. кол-во запросов. Какой наиболее длинный отрезок запросов (подпоследовательность идущих подряд
# запросов; пропускать запросы нельзя) сможет обработать сервер? Выведите длину такого отрезка запросов.
# Например, если последовательность имеет вид [7,1,4,1,9,1,1,9,1,7,9], то наиболее длинный отрезок запросов, который
# содержит запросы от не более чем двух клиентов — это [1,9,1,1,9,1]. Его длина равна 6.
# - Входные данные
# В первой строке записано целое число t (1≤t≤100) — кол-во наборов входных данных. Наборы являются независимыми.
# Друг на друга они не влияют.
# Первая строка каждого набора входных данных содержит целое число n (1≤n≤50) — количество запросов.
# Вторая строка набора содержит последовательность идентификаторов a1,a2,…,an (1≤ai≤109), где ai — целое число, которое
# обозначает идентификатор клиента, совершившего i-й запрос.
# 1
# 11
# 7 1 4 1 9 1 1 9 1 7 9
# - Выходные данные
# Для каждого набора вывести длину наибольшего отрезка запросов, в кот. запросы совершали не более двух разн. клиентов

count = int(input())

for x in range(count):
    req_count = int(input())
    client_ids = input().split()
    res_max_len = 0
    for i in range(req_count):
        clients_req = set()
        max_len = 0
        for cl_id in client_ids[i:]:
            clients_req.add(cl_id)
            if len(clients_req) <= 2:
                max_len += 1
            else:
                break
        if max_len > res_max_len:
            res_max_len = max_len

    print(res_max_len)
