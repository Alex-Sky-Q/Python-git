# Задан циклический двусвязный список целых чисел. Т.е. список замкнут в «кольцо», а для каждого его элемента известны
# его соседи (в произвольном порядке). Список задан набором троек вида «eiaibi». Каждая такая тройка означает, что
# соседями элемента ei являются элементы ai и bi. Всего в списке чётное количество элементов.
# Для каждого элемента выведите тот, который ему противоположен (т. е. расположен строго напротив, если изобразить
# список в виде правильного n-угольника).
# - Входные данные
# В первой строке входных данных записано целое число t (1≤t≤104) — количество наборов входных данных в тесте.
# Наборы входных данных в тесте являются независимыми. Друг на друга они никак не влияют.
# В первой строке набора записано чётное целое число n (4≤n≤105) — длина списка.
# Следующие n строк содержат тройки ei,ai,bi (1≤ei,ai,bi≤109). Все n элементов списка — различные числа.
# Сумма значений n по всем наборам входных данных теста не превосходит 105.
# 1
# 4
# 4 2 1
# 2 4 3
# 3 2 1
# 1 3 4
# - Выходные данные
# Для каждого набора выведите n/2 строк, каждая из которых содержит два целых числа xi,yi, которые означают, что
# элемент xi расположен строго напротив элемента yi. Числа в парах и сами пары можно выводить в любом порядке.
# Для улучшения читаемости между ответами для наборов выходных данных можно выводить пустую строку.

count = int(input())

for x in range(count):
    rows_count = int(input())
    num_dict = {}
    for r in range(rows_count):
        n, n1, n2 = map(int, input().split())
        num_dict[n] = (n1, n2)

    # print(num_dict)
    # {20: (30, 10), 40: (30, 50), 30: (20, 40), 60: (10, 50), 10: (60, 20), 50: (40, 60)}

    num_list = [n, n1]
    for i in range(rows_count-2):
        for n in num_dict[num_list[-1]]:
            if n != num_list[-2]:
                next_num = n
                break
        num_list.append(next_num)

    # print(num_list)

    opp = int(rows_count / 2)
    for i in range(opp):
        print(f'{num_list[i]} {num_list[i+opp]}')

    print()
